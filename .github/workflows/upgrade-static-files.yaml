---
name: Upgrade Static Files (CSS/JS)

on:
  workflow_call:
    inputs:
      libraries:
        description: 'Comma-separated list of libraries to check (e.g., "jquery,bootstrap")'
        required: false
        type: string
      static_base_path:
        description: 'Path to static_base directory (default: auto-detect)'
        required: false
        type: string
      upgrade_level:
        description: 'Level of upgrades to perform: patch, minor, or major (default: patch)'
        required: false
        type: string
        default: minor
  workflow_dispatch:
    inputs:
      libraries:
        description: 'Comma-separated list of libraries to check (e.g., "jquery,bootstrap")'
        required: false
        type: string
      static_base_path:
        description: 'Path to static_base directory (default: auto-detect)'
        required: false
        type: string
      upgrade_level:
        description: 'Level of upgrades to perform: patch, minor, or major (default: patch)'
        required: false
        type: choice
        options:
          - patch
          - minor
          - major
        default: minor
  schedule:
    # Runs every Monday at 6:00 UTC
    - cron: '0 6 * * 1'

jobs:
  check-updates:
    name: Check for Static File Updates
    runs-on: ubuntu-latest
    outputs:
      has_updates: ${{ steps.check.outputs.has_updates }}
      updates_summary: ${{ steps.check.outputs.summary }}
      has_major_upgrades: ${{ steps.check.outputs.has_major_upgrades }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v6
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install requests beautifulsoup4

      - name: Check for library updates
        id: check
        run: |
          python3 << 'EOF'
          import os
          import re
          import json
          import requests
          from pathlib import Path
          from bs4 import BeautifulSoup
          from urllib.parse import urljoin

          # Get upgrade level parameter
          upgrade_level = os.getenv('UPGRADE_LEVEL', 'patch').lower()
          if upgrade_level not in ['patch', 'minor', 'major']:
              upgrade_level = 'patch'
          print(f"ðŸ“Š Upgrade level: {upgrade_level}")
          
          # Auto-detect libraries from static files if not specified
          libraries_input = os.getenv('LIBRARIES_INPUT', '').strip()
          
          if libraries_input:
              libraries = [lib.strip() for lib in libraries_input.split(',') if lib.strip()]
              print(f"ðŸ” Using specified libraries: {', '.join(libraries)}")
          else:
              # Auto-detect libraries from static files
              print("ðŸ” Auto-detecting libraries from static files...")
              static_dirs = list(Path('.').glob('**/static_base/**/static/**')) + list(Path('.').glob('**/static/**'))
              
              detected_libraries = set()
              library_patterns = {
                  'jquery': [r'jquery', r'jq'],
                  'bootstrap': [r'bootstrap'],
                  'popper': [r'popper'],
                  'font-awesome': [r'font[-_]?awesome', r'fa\.(min\.)?(css|js)', r'all\.min\.css'],
                  'datatables': [r'datatables', r'data[-_]?tables'],
                  'select2': [r'select2'],
                  'moment': [r'moment(?!um)'],
                  'lodash': [r'lodash'],
                  'chart.js': [r'chart\.js', r'chartjs', r'chart\.'],
                  'sweetalert': [r'sweetalert'],
                  'toastr': [r'toastr'],
                  'animate.css': [r'animate\.css', r'animate'],
                  'highlight.js': [r'highlight\.js', r'highlightjs', r'highlight'],
              }
              
              for static_dir in static_dirs[:10]:  # Limit search
                  if not static_dir.is_dir():
                      continue
                  for file_path in static_dir.rglob('*'):
                      if file_path.is_file() and (file_path.suffix in ['.js', '.css', '.min.js', '.min.css']):
                          filename_lower = file_path.name.lower()
                          relative_path_lower = str(file_path.relative_to(static_dir)).lower().replace('\\', '/')
                          
                          for lib_name, patterns in library_patterns.items():
                              if lib_name in detected_libraries:  # Skip if already detected
                                  continue
                              for pattern in patterns:
                                  # Check both filename and relative path
                                  if re.search(pattern, filename_lower, re.IGNORECASE) or \
                                     re.search(pattern, relative_path_lower, re.IGNORECASE):
                                      detected_libraries.add(lib_name)
                                      break
              
              if detected_libraries:
                  libraries = sorted(list(detected_libraries))
                  print(f"âœ… Auto-detected libraries: {', '.join(libraries)}")
              else:
                  # Fallback to default if nothing detected
                  libraries = ['jquery', 'bootstrap', 'popper.js', 'font-awesome']
                  print(f"â„¹ï¸  No libraries auto-detected, using defaults: {', '.join(libraries)}")
          
          # Common CDN sources and version detection patterns
          cdn_sources = {
              'jquery': {
                  'url': 'https://api.cdnjs.com/libraries/jquery',
                  'version_key': 'version',
                  'latest_url': 'https://code.jquery.com/jquery.min.js'
              },
              'bootstrap': {
                  'url': 'https://api.cdnjs.com/libraries/bootstrap',
                  'version_key': 'version',
                  'latest_url': 'https://cdn.jsdelivr.net/npm/bootstrap@latest/dist/js/bootstrap.bundle.min.js'
              },
              'popper': {
                  'url': 'https://api.cdnjs.com/libraries/popper.js',
                  'version_key': 'version',
                  'latest_url': 'https://cdn.jsdelivr.net/npm/@popperjs/core@latest/dist/umd/popper.min.js'
              },
              'popper.js': {
                  'url': 'https://api.cdnjs.com/libraries/popper.js',
                  'version_key': 'version',
                  'latest_url': 'https://cdn.jsdelivr.net/npm/@popperjs/core@latest/dist/umd/popper.min.js'
              },
              'font-awesome': {
                  'url': 'https://api.cdnjs.com/libraries/font-awesome',
                  'version_key': 'version',
                  'latest_url': 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/latest/css/all.min.css'
              },
              'datatables': {
                  'url': 'https://api.cdnjs.com/libraries/datatables',
                  'version_key': 'version',
                  'latest_url': 'https://cdn.datatables.net/1.13.7/js/jquery.dataTables.min.js'
              },
              'select2': {
                  'url': 'https://api.cdnjs.com/libraries/select2',
                  'version_key': 'version',
                  'latest_url': 'https://cdn.jsdelivr.net/npm/select2@latest/dist/js/select2.min.js'
              },
              'moment': {
                  'url': 'https://api.cdnjs.com/libraries/moment.js',
                  'version_key': 'version',
                  'latest_url': 'https://cdnjs.cloudflare.com/ajax/libs/moment.js/latest/moment.min.js'
              },
              'lodash': {
                  'url': 'https://api.cdnjs.com/libraries/lodash.js',
                  'version_key': 'version',
                  'latest_url': 'https://cdn.jsdelivr.net/npm/lodash@latest/lodash.min.js'
              },
              'chart.js': {
                  'url': 'https://api.cdnjs.com/libraries/Chart.js',
                  'version_key': 'version',
                  'latest_url': 'https://cdn.jsdelivr.net/npm/chart.js@latest/dist/chart.umd.min.js'
              },
              'sweetalert': {
                  'url': 'https://api.cdnjs.com/libraries/sweetalert',
                  'version_key': 'version',
                  'latest_url': 'https://cdn.jsdelivr.net/npm/sweetalert2@latest/dist/sweetalert2.min.js'
              },
              'toastr': {
                  'url': 'https://api.cdnjs.com/libraries/toastr.js',
                  'version_key': 'version',
                  'latest_url': 'https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js'
              },
              'animate.css': {
                  'url': 'https://api.cdnjs.com/libraries/animate.css',
                  'version_key': 'version',
                  'latest_url': 'https://cdn.jsdelivr.net/npm/animate.css@latest/animate.min.css'
              },
              'highlight.js': {
                  'url': 'https://api.cdnjs.com/libraries/highlight.js',
                  'version_key': 'version',
                  'latest_url': 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/latest/highlight.min.js'
              }
          }
          
          # Find version files in repository
          version_files = []
          for pattern in ['**/versions.json', '**/versions.txt', '**/VERSION', '**/package.json', '**/static_base/versions.py']:
              version_files.extend(Path('.').glob(pattern))
          
          current_versions = {}
          libraries_from_versions = set()  # Track libraries found in versions.json
          
          if version_files:
              print(f"ðŸ“„ Found version files: {[str(f) for f in version_files]}")
              # Try to extract versions from files
              for vfile in version_files:
                  try:
                      content = vfile.read_text(encoding='utf-8')
                      # Try JSON
                      if vfile.suffix == '.json':
                          data = json.loads(content)
                          
                          # First, read versions for already detected libraries
                          for lib in libraries:
                              lib_lower = lib.lower().replace('-', '_').replace('.', '_')
                              if lib_lower in data:
                                  current_versions[lib] = str(data[lib_lower])
                          
                          # Also discover new libraries from versions.json
                          # Map from normalized keys back to library names
                          print(f"ðŸ” Checking versions.json for additional libraries...")
                          print(f"ðŸ“ Keys found in versions.json: {list(data.keys())}")
                          
                          # Common mappings from versions.json keys to library names
                          lib_name_map = {
                              'animate_css': 'animate.css',
                              'chart_js': 'chart.js',
                              'font_awesome': 'font-awesome',
                              'highlight_js': 'highlight.js',
                              'popper_js': 'popper',
                              'popper': 'popper',
                              'datatables': 'datatables',
                              'select2': 'select2',
                              'moment': 'moment',
                              'lodash': 'lodash',
                              'sweetalert': 'sweetalert',
                              'toastr': 'toastr',
                          }
                          
                          for key, version in data.items():
                              if not isinstance(version, str):
                                  continue
                              
                              # Normalize the key
                              key_lower = key.lower().strip()
                              
                              # Try to find matching library name from patterns
                              matched_lib = None
                              
                              # Method 1: Direct mapping
                              if key_lower in lib_name_map:
                                  matched_lib = lib_name_map[key_lower]
                              
                              # Method 2: Check if key matches library name exactly (with normalization)
                              if not matched_lib:
                                  for lib_name in library_patterns.keys():
                                      # Compare normalized forms
                                      lib_normalized = lib_name.lower().replace('-', '_').replace('.', '_')
                                      key_normalized = key_lower.replace('-', '_').replace('.', '_')
                                      
                                      if key_normalized == lib_normalized:
                                          matched_lib = lib_name
                                          break
                              
                              # Method 3: Try converting key to library format
                              if not matched_lib:
                                  # Convert underscore to dash/dot based on common patterns
                                  test_name = key_lower.replace('_', '-')
                                  if test_name in library_patterns:
                                      matched_lib = test_name
                                  else:
                                      test_name = key_lower.replace('_', '.')
                                      if test_name in library_patterns:
                                          matched_lib = test_name
                              
                              # Method 4: Fuzzy matching - check if key contains library name or vice versa
                              if not matched_lib:
                                  for lib_name in library_patterns.keys():
                                      lib_key = lib_name.lower().replace('-', '').replace('.', '').replace('_', '')
                                      key_clean = key_lower.replace('-', '').replace('.', '').replace('_', '')
                                      
                                      if lib_key in key_clean or key_clean in lib_key:
                                          matched_lib = lib_name
                                          break
                              
                              # If matched, add to libraries
                              if matched_lib and matched_lib in library_patterns:
                                  if matched_lib not in libraries:
                                      libraries.append(matched_lib)
                                      libraries_from_versions.add(matched_lib)
                                      print(f"ðŸ“‹ Found library in versions.json: {key} â†’ {matched_lib} = {version}")
                                  # Always update current_versions, even if library was already in list
                                  current_versions[matched_lib] = str(version)
                              else:
                                  # Debug: show what wasn't matched (exclude already detected libraries)
                                  detected_keys = [lib.lower().replace('-', '_').replace('.', '_') for lib in libraries]
                                  if key_lower not in detected_keys and key_lower.replace('_', '-') not in [lib.lower() for lib in libraries]:
                                      print(f"âš ï¸  Could not match versions.json key '{key}' (normalized: '{key_lower}') to any library pattern")
                          
                      # Try Python dict
                      elif vfile.suffix == '.py':
                          # Simple regex to find version assignments
                          for lib in libraries:
                              pattern = rf"{lib.lower().replace('-', '_')}\s*[=:]\s*['\"]([^'\"]+)['\"]"
                              match = re.search(pattern, content, re.IGNORECASE)
                              if match:
                                  current_versions[lib] = match.group(1)
                      # Try simple key=value format
                      else:
                          for line in content.split('\n'):
                              for lib in libraries:
                                  pattern = rf"{lib}\s*[=:]\s*([^\s]+)"
                                  match = re.search(pattern, line, re.IGNORECASE)
                                  if match:
                                      current_versions[lib] = match.group(1).strip('"\'')
                  except:
                      continue
          
          # Sort libraries list after adding from versions.json
          if libraries_from_versions:
              libraries = sorted(list(set(libraries)))
              print(f"ðŸ“š Added libraries from versions.json: {', '.join(sorted(libraries_from_versions))}")
          
          # If no version files found, try to detect from static files
          if not current_versions:
              print("ðŸ“ No version files found, checking static files...")
              static_dirs = list(Path('.').glob('**/static/**'))
              for static_dir in static_dirs[:5]:  # Limit search
                  for js_file in static_dir.glob('**/*.min.js'):
                      for lib in libraries:
                          if lib.lower() in js_file.name.lower():
                              # Try to extract version from filename or content
                              match = re.search(r'([0-9]+\.[0-9]+\.[0-9]+)', js_file.name)
                              if match:
                                  current_versions[lib] = match.group(1)
          
          print(f"ðŸ“Œ Current versions found: {current_versions}")
          
          # Helper function to determine version upgrade type
          def get_version_upgrade_type(current_ver, latest_ver):
              """Determine if upgrade is patch, minor, or major"""
              try:
                  # Clean version strings - remove any prefixes like 'v' or suffixes
                  current_clean = re.sub(r'^v?(\d+\.\d+\.\d+).*$', r'\1', str(current_ver).strip())
                  latest_clean = re.sub(r'^v?(\d+\.\d+\.\d+).*$', r'\1', str(latest_ver).strip())
                  
                  current = version.parse(current_clean)
                  latest = version.parse(latest_clean)
                  
                  if latest.major > current.major:
                      return 'major'
                  elif latest.minor > current.minor:
                      return 'minor'
                  elif latest.micro > current.micro:
                      return 'patch'
                  else:
                      return None  # Same or older version
              except Exception as e:
                  # If parsing fails, try to manually compare version numbers
                  try:
                      current_parts = [int(x) for x in str(current_ver).split('.')[:3]]
                      latest_parts = [int(x) for x in str(latest_ver).split('.')[:3]]
                      
                      if latest_parts[0] > current_parts[0]:
                          return 'major'
                      elif latest_parts[1] > current_parts[1]:
                          return 'minor'
                      elif len(latest_parts) > 2 and len(current_parts) > 2 and latest_parts[2] > current_parts[2]:
                          return 'patch'
                      return None
                  except:
                      # Last resort: assume patch for safety
                      return 'patch'
          
          # Check latest versions from CDN
          updates_available = {}
          major_versions_available = {}  # Track major versions not applied
          for lib in libraries:
              # Try multiple key variations
              lib_key = lib.lower().replace('.', '-').replace('_', '-')
              lib_key_alt = lib.lower().replace('-', '.').replace('_', '.')
              
              # Find matching source
              source = None
              for key in [lib_key, lib_key_alt, lib.lower()]:
                  if key in cdn_sources:
                      source = cdn_sources[key]
                      break
              
              if source:
                  try:
                      response = requests.get(source['url'], timeout=10)
                      if response.status_code == 200:
                          data = response.json()
                          latest_version = data.get(source['version_key'], '')
                          
                          if latest_version:
                              current = current_versions.get(lib, 'unknown')
                              if current != latest_version and latest_version != 'unknown' and current != 'unknown':
                                  # Check if latest is actually newer (not a downgrade)
                                  try:
                                      current_ver = version.parse(str(current))
                                      latest_ver = version.parse(str(latest_version))
                                      if latest_ver < current_ver:
                                          print(f"âš ï¸  {lib}: {current} â†’ {latest_version} (downgrade detected, skipping)")
                                          continue
                                  except:
                                      # If version parsing fails, try manual comparison
                                      try:
                                          current_parts = [int(x) for x in str(current).split('.')[:3]]
                                          latest_parts = [int(x) for x in str(latest_version).split('.')[:3]]
                                          # Compare parts in order: major, minor, patch
                                          for i in range(3):
                                              if latest_parts[i] < current_parts[i]:
                                                  print(f"âš ï¸  {lib}: {current} â†’ {latest_version} (downgrade detected, skipping)")
                                                  break
                                              elif latest_parts[i] > current_parts[i]:
                                                  break
                                          else:
                                              # All parts equal or latest is smaller - it's a downgrade or same
                                              if latest_parts < current_parts:
                                                  print(f"âš ï¸  {lib}: {current} â†’ {latest_version} (downgrade detected, skipping)")
                                                  continue
                                      except:
                                          pass  # If comparison fails, continue to normal upgrade check
                                  
                                  # Determine upgrade type
                                  upgrade_type = get_version_upgrade_type(current, latest_version)
                                  
                                  if upgrade_type is None:
                                      print(f"â„¹ï¸  {lib}: {current} (up to date)")
                                      continue
                                  
                                  upgrade_info = {
                                      'current': current,
                                      'latest': latest_version,
                                      'source': source,
                                      'upgrade_type': upgrade_type
                                  }
                                  
                                  # Filter by upgrade_level
                                  if upgrade_level == 'patch' and upgrade_type in ['minor', 'major']:
                                      # Skip minor/major, but log major
                                      if upgrade_type == 'major':
                                          major_versions_available[lib] = upgrade_info
                                          print(f"âš ï¸  {lib}: {current} â†’ {latest_version} ({upgrade_type}, skipped - only patch allowed)")
                                      else:
                                          print(f"â„¹ï¸  {lib}: {current} â†’ {latest_version} ({upgrade_type}, skipped - only patch allowed)")
                                  elif upgrade_level == 'minor' and upgrade_type == 'major':
                                      # Skip major, log it
                                      major_versions_available[lib] = upgrade_info
                                      print(f"âš ï¸  {lib}: {current} â†’ {latest_version} ({upgrade_type}, skipped - only minor/patch allowed)")
                                  else:
                                      # Apply update
                                      updates_available[lib] = upgrade_info
                                      print(f"âœ… {lib}: {current} â†’ {latest_version} ({upgrade_type})")
                              elif current == 'unknown':
                                  print(f"âš ï¸  {lib}: version unknown, skipping")
                              else:
                                  print(f"â„¹ï¸  {lib}: {current} (up to date)")
                      else:
                          print(f"âš ï¸  Failed to fetch version for {lib}: HTTP {response.status_code}")
                  except Exception as e:
                      print(f"âš ï¸  Error checking {lib}: {e}")
              else:
                  print(f"âš ï¸  No CDN source configured for {lib}, skipping...")
          
          # Save results
          output_file = os.getenv('GITHUB_OUTPUT')
          has_updates = len(updates_available) > 0
          
          with open(output_file, 'a', encoding='utf-8') as f:
              f.write(f"has_updates={'true' if has_updates else 'false'}\n")
              
              if updates_available:
                  summary = f"Found {len(updates_available)} update(s) (level: {upgrade_level}):\n"
                  for lib, info in updates_available.items():
                      summary += f"- {lib}: {info['current']} â†’ {info['latest']} ({info['upgrade_type']})\n"
                  f.write(f"summary<<EOF\n{summary}EOF\n")
                  
                  # Save JSON for next step
                  updates_file = Path('updates_available.json')
                  with open(updates_file, 'w', encoding='utf-8') as json_file:
                      json.dump(updates_available, json_file, indent=2)
              
              # Save major versions info
              if major_versions_available:
                  major_file = Path('major_versions_available.json')
                  with open(major_file, 'w', encoding='utf-8') as json_file:
                      json.dump(major_versions_available, json_file, indent=2)
                  with open(output_file, 'a', encoding='utf-8') as f:
                      f.write(f"has_major_upgrades=true\n")
              else:
                  with open(output_file, 'a', encoding='utf-8') as f:
                      f.write(f"has_major_upgrades=false\n")
          
          if has_updates:
              print(f"\nâœ… Found {len(updates_available)} update(s) available for {upgrade_level} level")
          else:
              print(f"\nâ„¹ï¸  No {upgrade_level} level updates available")
          
          if major_versions_available:
              print(f"\nâš ï¸  Found {len(major_versions_available)} major version(s) available but not applied:")
              for lib, info in major_versions_available.items():
                  print(f"   - {lib}: {info['current']} â†’ {info['latest']}")
          EOF
        env:
          LIBRARIES_INPUT: ${{ inputs.libraries || '' }}
          STATIC_BASE_PATH: ${{ inputs.static_base_path || '' }}

      - name: Upload updates data
        if: steps.check.outputs.has_updates == 'true'
        uses: actions/upload-artifact@v6
        with:
          name: updates-data
          path: updates_available.json
          retention-days: 1
      
      - name: Upload major versions data
        if: steps.check.outputs.has_major_upgrades == 'true'
        uses: actions/upload-artifact@v6
        continue-on-error: true
        with:
          name: major-versions-data
          path: major_versions_available.json
          retention-days: 1
          overwrite: true

  download-updates:
    name: Download Updated Static Files
    needs: check-updates
    if: needs.check-updates.outputs.has_updates == 'true'
    runs-on: ubuntu-latest
    outputs:
      files_updated: ${{ steps.download.outputs.files_updated }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.BOT_PAT || secrets.PERSONAL_TOKEN || secrets.GITHUB_TOKEN }}

      - uses: actions/setup-python@v6
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install requests beautifulsoup4

      - name: Download updates data
        uses: actions/download-artifact@v7
        with:
          name: updates-data
          path: .
      
      - name: Download major versions data
        uses: actions/download-artifact@v7
        continue-on-error: true
        with:
          name: major-versions-data
          path: .

      - name: Download updated files
        id: download
        run: |
          python3 << 'EOF'
          import os
          import json
          import requests
          from pathlib import Path
          from urllib.parse import urljoin, urlparse

          updates_file = Path('updates_available.json')
          if not updates_file.exists():
              print("âŒ updates_available.json not found")
              exit(1)
          
          with open(updates_file, 'r', encoding='utf-8') as f:
              updates = json.load(f)
          
          print(f"ðŸ“¥ Downloading {len(updates)} updated library files...")
          
          # Function to generate download URLs based on library name and version
          def get_download_urls(lib_name, version):
              lib_lower = lib_name.lower().replace('.', '-').replace('_', '-')
              
              urls = {}
              
              if lib_lower == 'jquery':
                  urls = {
                      'js': f"https://code.jquery.com/jquery-{version}.min.js",
                      'js_map': f"https://code.jquery.com/jquery-{version}.min.map"
                  }
              elif lib_lower == 'bootstrap':
                  urls = {
                      'css': f"https://cdn.jsdelivr.net/npm/bootstrap@{version}/dist/css/bootstrap.min.css",
                      'js': f"https://cdn.jsdelivr.net/npm/bootstrap@{version}/dist/js/bootstrap.bundle.min.js",
                      'css_map': f"https://cdn.jsdelivr.net/npm/bootstrap@{version}/dist/css/bootstrap.min.css.map",
                      'js_map': f"https://cdn.jsdelivr.net/npm/bootstrap@{version}/dist/js/bootstrap.bundle.min.js.map"
                  }
              elif lib_lower in ['popper', 'popper.js']:
                  urls = {
                      'js': f"https://cdn.jsdelivr.net/npm/@popperjs/core@{version}/dist/umd/popper.min.js",
                      'js_map': f"https://cdn.jsdelivr.net/npm/@popperjs/core@{version}/dist/umd/popper.min.js.map"
                  }
              elif lib_lower == 'font-awesome':
                  urls = {
                      'css': f"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/{version}/css/all.min.css"
                  }
              elif lib_lower == 'datatables':
                  urls = {
                      'css': f"https://cdn.datatables.net/{version}/css/jquery.dataTables.min.css",
                      'js': f"https://cdn.datatables.net/{version}/js/jquery.dataTables.min.js"
                  }
              elif lib_lower == 'select2':
                  urls = {
                      'css': f"https://cdn.jsdelivr.net/npm/select2@{version}/dist/css/select2.min.css",
                      'js': f"https://cdn.jsdelivr.net/npm/select2@{version}/dist/js/select2.min.js"
                  }
              elif lib_lower == 'moment':
                  urls = {
                      'js': f"https://cdnjs.cloudflare.com/ajax/libs/moment.js/{version}/moment.min.js"
                  }
              elif lib_lower == 'lodash':
                  urls = {
                      'js': f"https://cdn.jsdelivr.net/npm/lodash@{version}/lodash.min.js"
                  }
              elif lib_lower == 'chart.js':
                  urls = {
                      'js': f"https://cdn.jsdelivr.net/npm/chart.js@{version}/dist/chart.umd.min.js"
                  }
              elif lib_lower == 'sweetalert':
                  urls = {
                      'css': f"https://cdn.jsdelivr.net/npm/sweetalert2@{version}/dist/sweetalert2.min.css",
                      'js': f"https://cdn.jsdelivr.net/npm/sweetalert2@{version}/dist/sweetalert2.min.js"
                  }
              elif lib_lower == 'toastr':
                  urls = {
                      'css': f"https://cdnjs.cloudflare.com/ajax/libs/toastr.js/{version}/toastr.min.css",
                      'js': f"https://cdnjs.cloudflare.com/ajax/libs/toastr.js/{version}/toastr.min.js"
                  }
              elif lib_lower == 'animate.css':
                  urls = {
                      'css': f"https://cdn.jsdelivr.net/npm/animate.css@{version}/animate.min.css"
                  }
              elif lib_lower == 'highlight.js':
                  urls = {
                      'css': f"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/{version}/styles/default.min.css",
                      'js': f"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/{version}/highlight.min.js"
                  }
              else:
                  # Generic fallback: try to get from cdnjs
                  print(f"âš ï¸  No specific download URLs for {lib_name}, trying generic CDN...")
                  urls = {
                      'js': f"https://cdnjs.cloudflare.com/ajax/libs/{lib_lower}/{version}/{lib_lower}.min.js",
                      'css': f"https://cdnjs.cloudflare.com/ajax/libs/{lib_lower}/{version}/{lib_lower}.min.css"
                  }
              
              return urls
          
          # Find static_base directory
          static_base_dirs = list(Path('.').glob('**/static_base/**/static/**'))
          if not static_base_dirs:
              static_base_dirs = list(Path('.').glob('**/static/**'))
          
          if not static_base_dirs:
              print("âŒ Could not find static files directory")
              exit(1)
          
          static_dir = static_base_dirs[0]
          print(f"ðŸ“ Using static directory: {static_dir}")
          
          files_updated = []
          
          for lib, info in updates.items():
              lib_lower = lib.lower().replace('.', '-').replace('_', '-')
              version = info['latest']
              
              # Get download URLs using the function
              urls = get_download_urls(lib, version)
              
              if not urls:
                  print(f"âš ï¸  No download URLs found for {lib}, skipping...")
                  continue
              
              for file_type, url in urls.items():
                  try:
                      print(f"â¬‡ï¸  Downloading {lib} {file_type} from {url}...")
                      response = requests.get(url, timeout=30)
                      response.raise_for_status()
                      
                      # Determine target path
                  if 'css' in file_type:
                      target_dir = static_dir / 'base' / 'css'
                  elif 'js' in file_type:
                      target_dir = static_dir / 'base' / 'js'
                  else:
                      target_dir = static_dir / 'base'

                  target_dir.mkdir(parents=True, exist_ok=True)

                  # Determine filename
                  if lib_lower == 'jquery':
                      filename = 'jquery.min.js' if 'js' in file_type else 'jquery.min.js.map'
                  elif lib_lower == 'bootstrap':
                      if 'css' in file_type:
                          filename = 'bootstrap.min.css' if 'css' == file_type else 'bootstrap.min.css.map'
                      else:
                          filename = 'bootstrap.bundle.min.js' if 'js' == file_type else 'bootstrap.bundle.min.js.map'
                  elif lib_lower == 'popper.js':
                      filename = 'popper.min.js' if 'js' == file_type else 'popper.min.js.map'
                  elif lib_lower == 'font-awesome':
                      filename = 'all.min.css'
                  else:
                      filename = url.split('/')[-1]

                  target_path = target_dir / filename

                  # Save file
                  target_path.write_bytes(response.content)
                  files_updated.append(str(target_path))
                      print(f"âœ… Saved: {target_path}")
                      
                  except Exception as e:
                      print(f"âš ï¸  Error downloading {lib} {file_type}: {e}")
          
          # Update version file if exists and read current versions
          current_versions = {}  # Dictionary to hold all current library versions
          version_files = list(Path('.').glob('**/versions.json')) + list(Path('.').glob('**/static_base/versions.py'))
          for vfile in version_files:
              try:
                  if vfile.suffix == '.json':
                      data = json.loads(vfile.read_text(encoding='utf-8'))
                      
                      # First, read all current versions from the file
                      # Map normalized keys back to library names
                      lib_name_map = {
                          'animate_css': 'animate.css',
                          'chart_js': 'chart.js',
                          'font_awesome': 'font-awesome',
                          'highlight_js': 'highlight.js',
                          'popper_js': 'popper',
                          'popper': 'popper',
                          'datatables': 'datatables',
                          'select2': 'select2',
                          'moment': 'moment',
                          'lodash': 'lodash',
                          'sweetalert': 'sweetalert',
                          'toastr': 'toastr',
                          'jquery': 'jquery',
                          'bootstrap': 'bootstrap',
                      }
                      
                      for key, version in data.items():
                          if not isinstance(version, str):
                              continue
                          key_lower = key.lower()
                          # Map key to library name
                          lib_name = lib_name_map.get(key_lower, key.replace('_', '-'))
                          current_versions[lib_name] = version
                      
                      # Now update versions for libraries being updated
                      for lib, info in updates.items():
                          lib_key = lib.lower().replace('-', '_').replace('.', '_')
                          data[lib_key] = info['latest']
                          # Update current_versions with new version
                          current_versions[lib] = info['latest']
                      
                      vfile.write_text(json.dumps(data, indent=2) + '\n', encoding='utf-8')
                      files_updated.append(str(vfile))
                      print(f"âœ… Updated version file: {vfile}")
              except:
                  continue
          
          # Update documentation files (README.md, CHANGELOG.md, docs/*.md, docs/references/*.md)
          print("\nðŸ“š Checking documentation files for version references...")
          doc_files = []
          for pattern in ['README.md', 'CHANGELOG.md', '**/docs/**/*.md', 'docs/references/**/*.md', '**/*.rst']:
              doc_files.extend(Path('.').glob(pattern))
          
          # Remove duplicates
          doc_files = list(set(doc_files))
          
          # Combine updates with current_versions to update documentation for all libraries
          # This ensures documentation reflects all library versions, not just those being updated
          all_library_versions = {}
          for lib, info in updates.items():
              # Use new version for libraries being updated
              all_library_versions[lib] = info['latest']
          
          # Also include all other libraries from current_versions (even if not being updated)
          for lib, version in current_versions.items():
              if lib not in all_library_versions:
                  all_library_versions[lib] = version
          
          print(f"ðŸ“š Will update documentation for {len(all_library_versions)} libraries: {', '.join(sorted(all_library_versions.keys()))}")
          
          for doc_file in doc_files:
              if not doc_file.exists() or not doc_file.is_file():
                  continue
              
              try:
                  content = doc_file.read_text(encoding='utf-8')
                  original_content = content
                  updated = False
                  
                  # Update version references for each library (all libraries, not just updated ones)
                  for lib, new_version in all_library_versions.items():
                      lib_lower = lib.lower()
                      
                      # Skip if version is 'unknown' - can't safely update
                      if new_version == 'unknown' or not new_version:
                          continue
                      
                      # Try to find the old version in the document first
                      # Look for common patterns to find current version references
                      old_version_patterns = [
                          rf'{lib}\s*[:\-]\s*([0-9]+\.[0-9]+\.[0-9]+)',
                          rf'{lib_lower}\s*[=@]\s*([0-9]+\.[0-9]+\.[0-9]+)',
                          rf'{lib_lower}[\s\-_v]+([0-9]+\.[0-9]+\.[0-9]+)',
                          rf'\|\s*{lib}\s*\|\s*([0-9]+\.[0-9]+\.[0-9]+)',
                      ]
                      
                      old_version = None
                      for pattern in old_version_patterns:
                          match = re.search(pattern, content, re.IGNORECASE)
                          if match:
                              old_version = match.group(1)
                              break
                      
                      # If we can't find old version, skip this library for this file
                      # (to avoid replacing unrelated version numbers)
                      if not old_version:
                          continue
                      
                      # Skip if old version matches new version (already up to date)
                      if old_version == new_version:
                          continue
                      
                      # Pattern 1: "jquery: 3.7.0" or "jQuery: 3.7.0" or "jquery 3.7.0"
                      pattern1 = rf'({lib}|{lib.title()}|{lib.upper()})\s*[:\-]\s*{re.escape(old_version)}'
                      if re.search(pattern1, content, re.IGNORECASE):
                          content = re.sub(pattern1, rf'\1: {new_version}', content, flags=re.IGNORECASE)
                          updated = True
                      
                      # Pattern 2: "jquery==3.7.0" or "jquery@3.7.0"
                      pattern2 = rf'({lib_lower})\s*[=@]\s*{re.escape(old_version)}'
                      if re.search(pattern2, content, re.IGNORECASE):
                          content = re.sub(pattern2, rf'\1@{new_version}', content, flags=re.IGNORECASE)
                          updated = True
                      
                      # Pattern 3: "v3.7.0" or "version 3.7.0" near library name
                      pattern3 = rf'({lib_lower})(\s+[vV]?|[-_]){re.escape(old_version)}'
                      if re.search(pattern3, content, re.IGNORECASE):
                          content = re.sub(pattern3, rf'\1\2{new_version}', content, flags=re.IGNORECASE)
                          updated = True
                      
                      # Pattern 4: In tables or lists "| jQuery | 3.7.0 |"
                      pattern4 = rf'(\|\s*{lib}\s*\|\s*){re.escape(old_version)}(\s*\|)'
                      if re.search(pattern4, content, re.IGNORECASE):
                          content = re.sub(pattern4, rf'\1{new_version}\2', content, flags=re.IGNORECASE)
                          updated = True
                      
                      # Pattern 5: "jquery-3.7.0" in file paths or URLs
                      pattern5 = rf'({lib_lower.replace(".", "")})-{re.escape(old_version)}'
                      if re.search(pattern5, content, re.IGNORECASE):
                          content = re.sub(pattern5, rf'\1-{new_version}', content, flags=re.IGNORECASE)
                          updated = True
                      
                      # Pattern 6: In URLs "jquery/3.7.0"
                      pattern6 = rf'({lib_lower})\/{re.escape(old_version)}'
                      if re.search(pattern6, content, re.IGNORECASE):
                          content = re.sub(pattern6, rf'\1/{new_version}', content, flags=re.IGNORECASE)
                          updated = True
                      
                      # Pattern 7: Version comparison format "jquery 3.7.0 â†’ 3.7.1"
                      pattern7 = rf'({lib_lower})\s+{re.escape(old_version)}\s*â†’\s*([0-9.]+)'
                      if re.search(pattern7, content, re.IGNORECASE):
                          content = re.sub(pattern7, rf'\1 {new_version}', content, flags=re.IGNORECASE)
                          updated = True
                  
                  if updated:
                      doc_file.write_text(content, encoding='utf-8')
                      files_updated.append(str(doc_file))
                      print(f"âœ… Updated documentation: {doc_file}")
              except Exception as e:
                  print(f"âš ï¸  Error updating {doc_file}: {e}")
                  continue
          
          # Load major versions if exists (from artifact)
          major_versions_available = {}
          major_file = Path('major_versions_available.json')
          if major_file.exists():
              try:
                  with open(major_file, 'r', encoding='utf-8') as f:
                      major_versions_available = json.load(f)
              except:
                  pass
          
          # Update docs/references/*.md files with major versions info
          if major_versions_available:
              print("\nðŸ“ Updating docs/references/*.md with major version availability notices...")
              ref_files = list(Path('.').glob('docs/references/**/*.md'))
              
              for ref_file in ref_files:
                  if not ref_file.exists() or not ref_file.is_file():
                      continue
                  
                  try:
                      content = ref_file.read_text(encoding='utf-8')
                      original_content = content
                      
                      # Add or update a section about available major versions
                      major_section = "\n\n## Available Major Version Upgrades\n\n"
                      major_section += "âš ï¸ **Note**: The following libraries have major version upgrades available but were not applied:\n\n"
                      
                      for lib, info in major_versions_available.items():
                          major_section += f"- **{lib}**: Currently `{info['current']}`, latest major: `{info['latest']}`\n"
                      
                      major_section += "\nThese major versions are available but require manual review due to potential breaking changes.\n"
                      
                      # Check if section already exists
                      if "## Available Major Version Upgrades" in content:
                          # Replace existing section
                          pattern = r'## Available Major Version Upgrades.*?(?=\n##|\Z)'
                          content = re.sub(pattern, major_section.strip(), content, flags=re.DOTALL)
                      else:
                          # Append at the end
                          content = content.rstrip() + major_section
                      
                      if content != original_content:
                          ref_file.write_text(content, encoding='utf-8')
                          files_updated.append(str(ref_file))
                          print(f"âœ… Updated reference file with major versions: {ref_file}")
                  except Exception as e:
                      print(f"âš ï¸  Error updating reference file {ref_file}: {e}")
                      continue
          
          # Save list of updated files
          output_file = os.getenv('GITHUB_OUTPUT')
          with open(output_file, 'a', encoding='utf-8') as f:
              f.write(f"files_updated<<EOF\n{chr(10).join(files_updated)}\nEOF\n")
          
          print(f"\nâœ… Updated {len(files_updated)} file(s)")
          EOF

      - name: Upload updated files
        uses: actions/upload-artifact@v6
        with:
          name: updated-static-files
          path: |
            static_base/
            versions.json
            README.md
            CHANGELOG.md
            docs/
          retention-days: 1

  create-pr:
    name: Create Pull Request
    needs: [check-updates, download-updates]
    if: needs.check-updates.outputs.has_updates == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.BOT_PAT || secrets.PERSONAL_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Download updated files
        uses: actions/download-artifact@v7
        with:
          name: updated-static-files
          path: .

      - name: Verify downloaded files
        run: |
          echo "ðŸ” Verifying downloaded files..."
          if [ -f "versions.json" ]; then
            echo "âœ… versions.json found"
          else
            echo "âŒ versions.json NOT found"
            exit 1
          fi
          # Check if JS/CSS files are present
          if find . -path "*/static_base/*/*.min.js" -o -path "*/static_base/*/*.min.css" | head -1 > /dev/null; then
            echo "âœ… Found JS/CSS files in artifact"
            find . -path "*/static_base/*/*.min.js" -o -path "*/static_base/*/*.min.css" | head -5
          else
            echo "âš ï¸  No JS/CSS files found in artifact"
          fi
          echo "âœ… Artifact files downloaded successfully"
          # The create-pull-request action will automatically detect changes
          # compared to main and create the branch/commit/PR

      - name: Set branch name
        run: |
          BRANCH_NAME="update-static-files-$(date +%Y%m%d-%H%M%S)"
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
          echo "Branch name: $BRANCH_NAME"

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v8
        with:
          token: ${{ secrets.BOT_PAT || secrets.PERSONAL_TOKEN || secrets.GITHUB_TOKEN }}
          branch: ${{ env.BRANCH_NAME }}
          base: main
          delete-branch: true
          commit-message: "chore: Update static files (CSS/JS) to latest versions

          ${{ needs.check-updates.outputs.updates_summary }}

          Auto-generated by upgrade-static-files workflow."
          title: "chore: Update static files (CSS/JS) to latest versions"
          body: |
            ## ðŸ“¦ Static Files Update
            
            This PR updates CSS and JavaScript libraries to their latest versions.
            
            ${{ needs.check-updates.outputs.updates_summary }}
            
            ${{ needs.check-updates.outputs.has_major_upgrades == 'true' && format('### âš ï¸ Major Version Upgrades Available\n\nSome libraries have major version upgrades available but were not applied. Check `docs/references/*.md` files for details.\n\n') || '' }}
            
            ### Updated Files
            
            The following files have been updated:
            - CSS files in `static_base/static/base/css/`
            - JavaScript files in `static_base/static/base/js/`
            - Version configuration files (`versions.json`, `versions.py`, etc.)
            - Documentation files (`README.md`, `CHANGELOG.md`, `docs/*.md`) with updated version references
            
            ### Testing
            
            Please verify that:
            - [ ] All static files load correctly
            - [ ] No breaking changes in functionality
            - [ ] CSS styling remains consistent
            - [ ] JavaScript functionality works as expected
            
            ---
            Auto-generated by `upgrade-static-files.yaml` workflow.
          labels: |
            ðŸ“¦ dependencies
            ðŸŽ¨ frontend
          draft: false
